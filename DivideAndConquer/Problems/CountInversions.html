<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Count Inversions - CodeDSA</title>
  <link rel="stylesheet" href="../../CSS/AllProblems.css" />
  <link rel="stylesheet" href="../../CSS/breadcrumb.css" />
  <link rel="stylesheet" href="../../CSS/leetcodeButton.css">
  <link rel="stylesheet" href="../../CSS/snake.css" />
</head>

<body>
  <!-- Navbar -->
  <nav class="navbar">
     <a href="../../index.html" class="logo-container">
      <div class="logo-img">
        <img src="../../Images/logo.png" alt="Logo">
      </div>
      <div class="logo">CodeDSA</div>
    </a>
    <div class="nav-right">
      <ul class="nav-links">
        <li><a href="../../index.html">Home</a></li>
        <li><a href="../../about.html">About</a></li>
        <li><a href="../../contact.html">Contact</a></li>
      </ul>
      <button id="snakeToggle" class="snake-btn">
        <span style="margin-left: 20px">Snake Cursor</span>
      </button>
      <button id="darkModeToggle" class="dark-mode-btn">ðŸŒ™ Dark Mode</button>
    </div>
  </nav>

  <!-- Breadcrumb Navigation -->
  <div class="breadcrumb-container">
    <nav aria-label="breadcrumb">
      <ol class="breadcrumb">
        <li class="breadcrumb-item"><a href="../../index.html">Home</a></li>
        <li class="breadcrumb-item">
          <a href="../DivideAndConquerProblems.html">Divide and Conquer</a>
        </li>
        <li class="breadcrumb-item active" aria-current="page">
          Count Inversions
        </li>
      </ol>
    </nav>
  </div>

  <main>
    <h1>Count Inversions</h1>

    <!-- Problem Statement -->
    <section class="problem-section">
      <h2>Problem Statement</h2>
      <p>
        Given an array <strong>arr[]</strong>, count the number of
        <strong>inversions</strong> in the array. Two elements arr[i] and
        arr[j] form an inversion if <strong>i &lt; j</strong> and
        <strong>arr[i] &gt; arr[j]</strong>.
      </p>
      <p>
        <strong>Example:</strong> Input: arr = [8, 4, 2, 1]<br />
        Output: 6<br />
        Explanation: Inversions are (8,4), (8,2), (8,1), (4,2), (4,1), (2,1).
      </p>
    </section>

    <!-- Approaches -->
    <section class="approach-section">
      <h2>Approach 1: Brute Force</h2>
      <p>
        <strong>Explanation:</strong> Use two nested loops to check every pair
        of elements and count inversions where i &lt; j and arr[i] &gt;
        arr[j].
      </p>
      <p><strong>Time Complexity:</strong> O(n<sup>2</sup>)</p>
      <p><strong>Space Complexity:</strong> O(1)</p>
      <pre class="pseudo-code">
function countInversions(arr):
    n = length(arr)
    count = 0
    
    for i = 0 to n-2:
        for j = i+1 to n-1:
            if arr[i] &gt; arr[j]:
                count = count + 1
    
    return count
          </pre> <button class="copyToClipboard" onclick="copyToClipboard(this)">Copy!</button>

    </section>

    <section class="approach-section">
      <h2>Approach 2: Optimized Brute Force with Early Termination</h2>
      <p>
        <strong>Explanation:</strong> Similar to brute force but with minor
        optimizations like reducing redundant comparisons. Though still O(nÂ²),
        it performs better in practice by avoiding unnecessary iterations when
        possible.
      </p>
      <p><strong>Time Complexity:</strong> O(n<sup>2</sup>)</p>
      <p><strong>Space Complexity:</strong> O(1)</p>
      <pre class="pseudo-code">
function countInversions(arr):
    n = length(arr)
    count = 0
    
    for i = 0 to n-2:
        // Early termination: if current element is smallest, 
        // no inversions possible
        if arr[i] &lt;= min(arr[i+1] to arr[n-1]):
            continue
            
        for j = i+1 to n-1:
            if arr[i] &gt; arr[j]:
                count = count + 1
    
    return count

         </pre> <button class="copyToClipboard" onclick="copyToClipboard(this)">Copy!</button>

    </section>

    <section class="approach-section">
      <h2>Approach 3: Divide and Conquer (Modified Merge Sort)</h2>
      <p>
        <strong>Explanation:</strong> Divide the array into two halves. Count
        inversions in left half, right half, and cross inversions during
        merge. When merging, if an element from the right half is smaller than
        an element from the left half, all remaining elements in the left half
        form inversions with it.
      </p>
      <p><strong>Time Complexity:</strong> O(n log n)</p>
      <p><strong>Space Complexity:</strong> O(n) for temporary array</p>
      <pre class="pseudo-code">
function mergeAndCount(arr, temp, left, mid, right):
    i = left
    j = mid + 1
    k = left
    invCount = 0
    
    while i &lt;= mid and j &lt;= right:
        if arr[i] &lt;= arr[j]:
            temp[k] = arr[i]
            i = i + 1
        else:
            temp[k] = arr[j]
            invCount = invCount + (mid - i + 1)
            j = j + 1
        k = k + 1
    
    while i &lt;= mid:
        temp[k] = arr[i]
        i = i + 1
        k = k + 1
    
    while j &lt;= right:
        temp[k] = arr[j]
        j = j + 1
        k = k + 1
    
    for i = left to right:
        arr[i] = temp[i]
    
    return invCount

function mergeSortAndCount(arr, temp, left, right):
    invCount = 0
    if left &lt; right:
        mid = (left + right) / 2
        
        invCount = invCount + mergeSortAndCount(arr, temp, left, mid)
        invCount = invCount + mergeSortAndCount(arr, temp, mid+1, right)
        invCount = invCount + mergeAndCount(arr, temp, left, mid, right)
    
    return invCount

    function countInversions(arr):
    n = length(arr)
    temp = new array of size n
    return mergeSortAndCount(arr, temp, 0, n-1)
            </pre> <button class="copyToClipboard" onclick="copyToClipboard(this)">Copy!</button>


    </section>

    <br />

    <p>
      <strong>The Divide and Conquer approach using Modified Merge Sort is the most
        commonly used optimal solution for counting inversions with O(n log n)
        time complexity. It elegantly combines sorting with inversion
        counting.</strong>
    </p>

    <br />

    <!-- Flowchart Section -->
    <section>
      <button id="toggleBtn" class="toggle-btn">Show Flowchart â–²</button>
      <div id="flowchart" class="flowchart-container">
        <img src="../flowcharts/problem3.png" alt="Flowchart" height="1000px" width="500px" />
      </div>
    </section>
    <a 
        href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/" 
        class="leetcode-btn" 
        target="_blank">
        Solve on LeetCode
    </a>

  </main>

  <!-- Footer -->
  <footer>
    <p>&copy; 2025 Mrunalini Pachpute. All rights reserved.</p>
  </footer>

  <script src="../../index.js"></script>
  <script src="../../copyToClipboard.js"></script>
  <script src="../../JS/problemTracker.js"></script>
</body>

</html>