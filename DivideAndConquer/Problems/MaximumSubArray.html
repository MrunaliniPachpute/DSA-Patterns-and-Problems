<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Maximum SubArray - CodeDSA</title>
  <link rel="stylesheet" href="../../CSS/AllProblems.css" />
  <link rel="stylesheet" href="../../CSS/breadcrumb.css" />
  <link rel="stylesheet" href="../../CSS/snake.css" />
</head>

<body>
  <!-- Navbar -->
  <nav class="navbar">
    <a href="../../index.html" class="logo-container">
      <div class="logo-img">
        <img src="../../Images/logo.png" alt="Logo">
      </div>
      <div class="logo">CodeDSA</div>
    </a>
    <div class="nav-right">
      <ul class="nav-links">
        <li><a href="../../index.html">Home</a></li>
        <li><a href="../../about.html">About</a></li>
        <li><a href="../../contact.html">Contact</a></li>
      </ul>
      <button id="snakeToggle" class="snake-btn">
        <span style="margin-left: 20px">Snake Cursor</span>
      </button>
      <button id="darkModeToggle" class="dark-mode-btn">ðŸŒ™ Dark Mode</button>
    </div>
  </nav>

  <!-- Breadcrumb Navigation -->
  <div class="breadcrumb-container">
    <nav aria-label="breadcrumb">
      <ol class="breadcrumb">
        <li class="breadcrumb-item"><a href="../../index.html">Home</a></li>
        <li class="breadcrumb-item">
          <a href="../DivideAndConquerProblems.html">Divide and Conquer</a>
        </li>
        <li class="breadcrumb-item active" aria-current="page">
          Maximum SubArray
        </li>
      </ol>
    </nav>
  </div>

  <main>
    <h1>Maximum SubArray</h1>

    <!-- Problem Statement -->
    <section class="problem-section">
      <h2>Problem Statement</h2>
      <p>
        Given an integer array <strong>nums[]</strong>, find the
        <strong>contiguous subarray</strong> (containing at least one number)
        which has the <strong>largest sum</strong> and return its sum.
      </p>
      <p>
        <strong>Example:</strong> Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5,
        4]<br />
        Output: 6<br />
        Explanation: [4, -1, 2, 1] has the largest sum = 6.
      </p>
    </section>

    <!-- Approaches -->
    <section class="approach-section">
      <h2>Approach 1: Brute Force</h2>
      <p>
        <strong>Explanation:</strong> Generate all possible subarrays and
        calculate their sum to find the maximum.
      </p>
      <p><strong>Time Complexity:</strong> O(n<sup>3</sup>)</p>
      <p><strong>Space Complexity:</strong> O(1)</p>
      <pre class="pseudo-code">
function maxSubArray(arr):
    n = length(arr)
    maxSum = -infinity
    
    for i = 0 to n-1:
        for j = i to n-1:
            currentSum = 0
            for k = i to j:
                currentSum = currentSum + arr[k]
            maxSum = max(maxSum, currentSum)
    
    return maxSum
          </pre> <button class="copyToClipboard" onclick="copyToClipboard(this)">Copy!</button>

    </section>

    <section class="approach-section">
      <h2>Approach 2: Divide and Conquer</h2>
      <p>
        <strong>Explanation:</strong> Divide the array into two halves. The
        maximum subarray can be in the left half, right half, or crossing the
        middle. Recursively find the maximum in each case.
      </p>
      <p><strong>Time Complexity:</strong> O(n log n)</p>
      <p>
        <strong>Space Complexity:</strong> O(log n) due to recursive stack
      </p>
      <pre class="pseudo-code">
function maxCrossingSum(arr, low, mid, high):
    leftSum = -infinity
    sum = 0
    for i = mid down to low:
        sum = sum + arr[i]
        leftSum = max(leftSum, sum)
    
    rightSum = -infinity
    sum = 0
    for i = mid+1 to high:
        sum = sum + arr[i]
        rightSum = max(rightSum, sum)
    
    return leftSum + rightSum

function maxSubArrayDC(arr, low, high):
    if low == high:
        return arr[low]
    
    mid = (low + high) / 2
    
    leftMax = maxSubArrayDC(arr, low, mid)
    rightMax = maxSubArrayDC(arr, mid+1, high)
    crossMax = maxCrossingSum(arr, low, mid, high)
    
    return max(leftMax, rightMax, crossMax)

function maxSubArray(arr):
    return maxSubArrayDC(arr, 0, length(arr)-1)
            </pre> <button class="copyToClipboard" onclick="copyToClipboard(this)">Copy!</button>


    </section>

    <section class="approach-section">
      <h2>Approach 3: Kadane's Algorithm (Dynamic Programming)</h2>
      <p>
        <strong>Explanation:</strong> Keep track of the maximum sum ending at
        each position. At each element, decide whether to extend the existing
        subarray or start a new one.
      </p>
      <p><strong>Time Complexity:</strong> O(n)</p>
      <p><strong>Space Complexity:</strong> O(1)</p>
      <pre class="pseudo-code">
function maxSubArray(arr):
    n = length(arr)
    maxSum = arr[0]
    currentSum = arr[0]
    
    for i = 1 to n-1:
        currentSum = max(arr[i], currentSum + arr[i])
        maxSum = max(maxSum, currentSum)
    
    return maxSum
          </pre> <button class="copyToClipboard" onclick="copyToClipboard(this)">Copy!</button>

    </section>

    <p>
      <strong>
        Though Divide and Conquer is not the most optimal approach for this
        problem, it is included here to illustrate the Divide and Conquer
        pattern. The optimal solution is Kadane's Algorithm with O(n) time
        complexity.</strong>
    </p>
    <br />

    <!-- Flowchart Section -->
    <section>
      <button id="toggleBtn" class="toggle-btn">Show Flowchart â–²</button>
      <div id="flowchart" class="flowchart-container">
        <img src="../flowcharts/problem2.png" alt="Flowchart" height="1000px" width="500px" />
      </div>
    </section>
  </main>

  <!-- Footer -->
  <footer>
    <p>&copy; 2025 Mrunalini Pachpute. All rights reserved.</p>
  </footer>

  <script src="../../index.js"></script>
  <script src="../../copyToClipboard.js"></script>
  <script src="../../JS/problemTracker.js"></script>
</body>

</html>