<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Combination Sum - CodeDSA</title>
  <link rel="stylesheet" href="../../CSS/AllProblems.css">
  <link rel="stylesheet" href="../../CSS/breadcrumb.css">
  <link rel="stylesheet" href="../../CSS/snake.css">
</head>
<body>

  <nav class="navbar">
    <div class="logo">CodeDSA</div>
    <div class="nav-right">
    <ul class="nav-links">
      <li><a href="../../index.html">Home</a></li>
      <li><a href="../../about.html">About</a></li>
      <li><a href="../../contact.html">Contact</a></li>
    </ul>
    <button id="snakeToggle" class="snake-btn"><span style="margin-left: 20px;">Snake Cursor</span></button>
    <button id="darkModeToggle" class="dark-mode-btn">ðŸŒ™ Dark Mode</button>
    </div>
  </nav>

  <div class="breadcrumb-container">
    <nav aria-label="breadcrumb">
      <ol class="breadcrumb">
        <li class="breadcrumb-item"><a href="../../index.html">Home</a></li>
        <li class="breadcrumb-item"><a href="../Backtracking.html">Backtracking</a></li>
        <li class="breadcrumb-item active" aria-current="page">Combination Sum</li>
      </ol>
    </nav>
  </div>

  <main>
    <h1>Combination Sum</h1>

    <section class="problem-section">
      <h2>Problem Statement</h2>
      <p>Given an array of distinct integers <strong>candidates</strong> and a target integer <strong>target</strong>, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times.</p>
      <p><strong>Example:</strong> Input: candidates = [2,3,6,7], target = 7 â†’ Output: [[2,2,3],[7]]</p>
    </section>

    <section class="approach-section">
      <h2>Approach 1: Brute-Force Backtracking</h2>
      <p><strong>Explanation (Brute):</strong> A standard recursive backtracking approach. At each step, iterate through all candidates. If a candidate is less than or equal to the remaining target, add it to the current combination and recurse with the new target. Backtrack by removing the candidate to explore other possibilities.</p>
      <p><strong>Time Complexity:</strong> O(N^(T/M + 1)), where N is number of candidates, T is target, M is min candidate value.</p>
      <p><strong>Space Complexity:</strong> O(T/M) for recursion depth.</p>
      <pre class="pseudo-code">
function findCombinations(candidates, target):
    result = []
    backtrack(result, [], candidates, target, 0)
    return result

function backtrack(result, current, candidates, remain, start):
    if remain < 0:
        return
    if remain == 0:
        add copy of current to result
        return
    for i from start to length(candidates)-1:
        current.push(candidates[i])
        backtrack(result, current, candidates, remain - candidates[i], i) // 'i' allows reuse of same element
        current.pop()
      </pre>
    </section>

    <section class="approach-section">
      <h2>Approach 2: Backtracking with Pruning</h2>
      <p><strong>Explanation (Better):</strong> The brute-force approach can be slightly optimized. By sorting the candidates array first, we can stop exploring a path as soon as the current candidate is greater than the remaining target. This prunes branches of the recursion tree that will not lead to a solution.</p>
      <p><strong>Time Complexity:</strong> Similar to brute-force, but faster in practice due to pruning.</p>
      <p><strong>Space Complexity:</strong> O(T/M).</p>
      <pre class="pseudo-code">
// Same as above, but with a check inside the loop:
sort(candidates)
...
for i from start to length(candidates)-1:
    if candidates[i] > remain:
        break // Pruning step
    current.push(candidates[i])
    backtrack(...)
    current.pop()
      </pre>
    </section>

    <section class="approach-section">
      <h2>Approach 3: Dynamic Programming</h2>
      <p><strong>Explanation (Optimal for related problems):</strong> While backtracking is needed to find *all* combinations, if the problem was to just count the number of combinations, Dynamic Programming would be more optimal. A DP array `dp[i]` could store the number of ways to make sum `i`. This approach is not directly applicable for listing all combinations but is a key alternative for similar problems.</p>
      <p><strong>Time Complexity:</strong> O(N * T)</p>
      <p><strong>Space Complexity:</strong> O(T)</p>
      <pre class="pseudo-code">
// For counting combinations
dp = array of size (target + 1) filled with 0
dp[0] = 1
for candidate in candidates:
    for j from candidate to target:
        dp[j] = dp[j] + dp[j - candidate]
return dp[target]
      </pre>
    </section>

    <section class="approach-section">
      <h2>C# Implementation</h2>
      <p><strong>Implementation of the optimized backtracking approach (Approach 2) in C#:</strong></p>
      <pre class="pseudo-code">
public class Solution {
    public IList<IList<int>> CombinationSum(int[] candidates, int target) {
        var result = new List<IList<int>>();
        // Sort candidates for optimization (pruning)
        Array.Sort(candidates);
        Backtrack(candidates, target, 0, new List<int>(), result);
        return result;
    }
    
    private void Backtrack(int[] candidates, int remain, int start, 
                          List<int> current, IList<IList<int>> result) {
        // Base case: if remaining sum is 0, we found a valid combination
        if (remain == 0) {
            result.Add(new List<int>(current)); // Add a copy of current combination
            return;
        }
        
        // Try each candidate from the start index
        for (int i = start; i < candidates.Length; i++) {
            // Pruning: if current candidate is larger than remaining sum, skip this
            // and all following candidates (they're larger as array is sorted)
            if (candidates[i] > remain) {
                break;
            }
            
            // Include current candidate
            current.Add(candidates[i]);
            
            // Recurse with remaining sum and same start index (can reuse same number)
            Backtrack(candidates, remain - candidates[i], i, current, result);
            
            // Backtrack: remove the current candidate to try next one
            current.RemoveAt(current.Count - 1);
        }
    }
}
      </pre>
      <button class="copyToClipboard" onclick="copyToClipboard(this)">Copy!</button>
      <p>
        <strong>Usage:</strong><br>
        1. Create an instance of Solution class<br>
        2. Call CombinationSum method with your candidates array and target sum<br>
        3. Example: <br>
        var result = new Solution().CombinationSum(new int[] {2,3,6,7}, 7);<br>
        // This will return: [[2,2,3],[7]]
      </p>
    </section>
  </main>

  <footer>
    <p>&copy; 2025 Mrunalini Pachpute. All rights reserved.</p>
  </footer>
  <script src="../../index.js"></script>
</body>
</html>