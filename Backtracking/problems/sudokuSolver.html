<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sudoku Solver - CodeDSA</title>
  <link rel="stylesheet" href="../../CSS/AllProblems.css">
  <link rel="stylesheet" href="../../CSS/breadcrumb.css">
  <link rel="stylesheet" href="../../CSS/snake.css">
</head>
<body>

  <nav class="navbar">
    <div class="logo">CodeDSA</div>
    <div class="nav-right">
    <ul class="nav-links">
      <li><a href="../../index.html">Home</a></li>
      <li><a href="../../about.html">About</a></li>
      <li><a href="../../contact.html">Contact</a></li>
    </ul>
    <button id="snakeToggle" class="snake-btn"><span style="margin-left: 20px;">Snake Cursor</span></button>
    <button id="darkModeToggle" class="dark-mode-btn">ðŸŒ™ Dark Mode</button>
    </div>
  </nav>

  <div class="breadcrumb-container">
    <nav aria-label="breadcrumb">
      <ol class="breadcrumb">
        <li class="breadcrumb-item"><a href="../../index.html">Home</a></li>
        <li class="breadcrumb-item"><a href="../Backtracking.html">Backtracking</a></li>
        <li class="breadcrumb-item active" aria-current="page">Sudoku Solver</li>
      </ol>
    </nav>
  </div>

  <main>
    <h1>Sudoku Solver</h1>

    <section class="problem-section">
      <h2>Problem Statement</h2>
      <p>Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: 1. Each of the digits 1-9 must occur exactly once in each row. 2. Each of the digits 1-9 must occur exactly once in each column. 3. Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.</p>
      <p><strong>Example:</strong> Given a partially filled 9x9 grid, return the solved grid.</p>
    </section>

    <section class="approach-section">
      <h2>Approach 1: Simple Backtracking</h2>
      <p><strong>Explanation (Brute):</strong> Find the first empty cell ('.'). Try placing numbers from 1 to 9 in that cell. For each number, check if it's valid (doesn't violate Sudoku rules). If it's valid, recursively call the solver for the next empty cell. If the recursive call returns true, a solution is found. If not, backtrack by resetting the cell to '.' and try the next number.</p>
      <p><strong>Time Complexity:</strong> O(9^(N*N)), where N is 9. In practice, it's much faster due to constraints.</p>
      <p><strong>Space Complexity:</strong> O(N*N) for the recursion stack depth.</p>
      <pre class="pseudo-code">
function solveSudoku(board):
    for row from 0 to 8:
        for col from 0 to 8:
            if board[row][col] == '.':
                for num from 1 to 9:
                    if isValid(board, row, col, num):
                        board[row][col] = num
                        if solveSudoku(board) == true:
                            return true
                        else:
                            board[row][col] = '.' // Backtrack
                return false
    return true // Board is solved
      </pre>
    </section>

    <section class="approach-section">
      <h2>Approach 2: Backtracking with Pre-computation</h2>
      <p><strong>Explanation (Better):</strong> Instead of repeatedly checking rows, columns, and boxes for validity, we can use boolean arrays (or hash sets) to keep track of which numbers are already used in each row, column, and 3x3 box. This makes the `isValid` check an O(1) operation instead of O(N).</p>
      <p><strong>Time Complexity:</strong> Still exponential, but the constant factor is significantly smaller.</p>
      <p><strong>Space Complexity:</strong> O(N*N) to store the pre-computed states.</p>
      <pre class="pseudo-code">
// Initialize rows[9][10], cols[9][10], boxes[9][10] to false
// Pre-populate these arrays based on the initial board state

function solve():
    // find empty cell (row, col)
    ...
    for num from 1 to 9:
        if not rows[row][num] and not cols[col][num] and not boxes[box_index][num]:
            // place number and update boolean arrays
            solve()
            // backtrack and reset boolean arrays
      </pre>
    </section>
    
    <section class="approach-section">
      <h2>Approach 3: Optimized Backtracking (Heuristics)</h2>
      <p><strong>Explanation (Optimal):</strong> A powerful heuristic is to not just find the *next* empty cell, but to find the empty cell with the *fewest possible valid placements*. This is called the "Most Constrained Heuristic". By solving the most constrained cells first, we are likely to prune the search tree much more aggressively, leading to a much faster solution.</p>
      <p><strong>Time Complexity:</strong> Same worst-case, but significantly faster on average Sudoku puzzles.</p>
      <p><strong>Space Complexity:</strong> O(N*N).</p>
      <pre class="pseudo-code">
function solve():
    find the empty cell with the minimum number of valid candidate numbers
    if no such cell:
        return true // solved
    
    for each valid candidate number for that cell:
        place number
        if solve() == true:
            return true
        backtrack
    return false
      </pre>
    </section>

    <section class="approach-section">
      <h2>C# Implementation</h2>
      <p><strong>Implementation of the optimized backtracking approach with pre-computation (Approach 2) in C#:</strong></p>
      <pre class="pseudo-code">
public class Solution {
    private bool[][] rows = new bool[9][];    // rows[r][n] means number n is used in row r
    private bool[][] cols = new bool[9][];    // cols[c][n] means number n is used in column c
    private bool[][] boxes = new bool[9][];   // boxes[b][n] means number n is used in box b
    
    public void SolveSudoku(char[][] board) {
        // Initialize tracking arrays
        for (int i = 0; i < 9; i++) {
            rows[i] = new bool[10];   // 0-9, we'll ignore index 0
            cols[i] = new bool[10];
            boxes[i] = new bool[10];
        }
        
        // Pre-process the board to mark used numbers
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] != '.') {
                    int num = board[i][j] - '0';
                    int boxIndex = (i / 3) * 3 + j / 3;
                    rows[i][num] = true;
                    cols[j][num] = true;
                    boxes[boxIndex][num] = true;
                }
            }
        }
        
        // Solve the board
        Solve(board);
    }
    
    private bool Solve(char[][] board) {
        // Find empty cell with fewest possibilities (optimization)
        int minPossibilities = 10;
        int bestRow = -1, bestCol = -1;
        
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] == '.') {
                    int possibilities = CountPossibilities(i, j);
                    if (possibilities < minPossibilities) {
                        minPossibilities = possibilities;
                        bestRow = i;
                        bestCol = j;
                    }
                }
            }
        }
        
        // If no empty cell found, puzzle is solved
        if (bestRow == -1 && bestCol == -1) {
            return true;
        }
        
        int boxIndex = (bestRow / 3) * 3 + bestCol / 3;
        
        // Try each possible number
        for (int num = 1; num <= 9; num++) {
            if (!rows[bestRow][num] && !cols[bestCol][num] && !boxes[boxIndex][num]) {
                // Place the number
                board[bestRow][bestCol] = (char)(num + '0');
                rows[bestRow][num] = true;
                cols[bestCol][num] = true;
                boxes[boxIndex][num] = true;
                
                // Recurse
                if (Solve(board)) {
                    return true;
                }
                
                // Backtrack
                board[bestRow][bestCol] = '.';
                rows[bestRow][num] = false;
                cols[bestCol][num] = false;
                boxes[boxIndex][num] = false;
            }
        }
        
        return false;
    }
    
    private int CountPossibilities(int row, int col) {
        int boxIndex = (row / 3) * 3 + col / 3;
        int count = 0;
        
        for (int num = 1; num <= 9; num++) {
            if (!rows[row][num] && !cols[col][num] && !boxes[boxIndex][num]) {
                count++;
            }
        }
        
        return count;
    }
}
      </pre>
      <button class="copyToClipboard" onclick="copyToClipboard(this)">Copy!</button>
      <p>
        <strong>Usage:</strong><br>
        1. Create an instance of Solution class<br>
        2. Create a 9x9 char array representing the Sudoku board<br>
        3. Call SolveSudoku method with your board<br>
        4. Example: <br>
        var board = new char[][] {<br>
            new char[] {'5','3','.','.','7','.','.','.','.'},<br>
            new char[] {'6','.','.','1','9','5','.','.','.'},<br>
            new char[] {'.','9','8','.','.','.','.','6','.'},<br>
            new char[] {'8','.','.','.','6','.','.','.','3'},<br>
            new char[] {'4','.','.','8','.','3','.','.','1'},<br>
            new char[] {'7','.','.','.','2','.','.','.','6'},<br>
            new char[] {'.','6','.','.','.','.','2','8','.'},<br>
            new char[] {'.','.','.','4','1','9','.','.','5'},<br>
            new char[] {'.','.','.','.','8','.','.','7','9'}<br>
        };<br>
        new Solution().SolveSudoku(board);<br>
        // The board will be modified in place with the solution
      </p>
    </section>
  </main>

  <footer>
    <p>&copy; 2025 Mrunalini Pachpute. All rights reserved.</p>
  </footer>
  <script src="../../index.js"></script>
</body>
</html>